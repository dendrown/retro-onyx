(*
 * ONYXLOGO
 * Onyx Technologies logo and more!
 *
 * Author: Dennis Drown
 * System: Apple II Pascal
 *)
(*$S+*)
PROGRAM OnyxLogo(INPUT, OUTPUT);
USES AppleStuff, Transcend, TurtleGraphics;

CONST
  RADIUS1       = 10;           (* Four concentric circles, start @ innermost *)
  DELTAR        = 15;           (* Expand each circle this far: 10,25,40,55 *)
  NUMCIRCLES    = 4;
  CIRCSECTIONS  = 10;           (* Chop a circle into this many sections *)
  XMAX          = 279;          (* Max horiz. pixel index for full screen *)
  YMAX          = 191;          (* Max vert.  pixel index for full screen *)
  XCENTRE       = 139;          (* XMAX div 2 *)
  YCENTRE       = 95;           (* YMAX div 2 *)
  TEXTLINE      = 8;            (* Text line height in pixels *)

TYPE
  StatusLine    = 1..10;

  (* TODO: Comupute the circles once, and redraw from NE arcs
  ArcSegments = Array[1..RADIUS1+RADIUS2+RADIUS3+RADIUS4] of Integer;
  *)
 SectorArc = Array[1..130] of Integer; (* TODO: "fake" dynamic ranging *)
  Blueprint = Record
                (* TODO: make this sane as we handle the multi-circle spec *)
                Radii   : Array[1..NUMCIRCLES] of Integer;
                BegArcY : Array[1..NUMCIRCLES] of SectorArc; (* TODO: resize *)
                EndArcY : Array[1..NUMCIRCLES] of SectorArc; (* TODO: resize *)
              End;

VAR
  Answer    : Char;             (* Input to see if user wishes to continue *)
  I         : Integer;
  Logo      : Blueprint;

(*
 * PrepDrawXY
 * Outputs a string in graphics mode
 *)
PROCEDURE PrepDrawXY(X, Y : Integer);
BEGIN
  PenColor(NONE);
  MoveTo(X, Y);
  PenColor(WHITE)
END; (* PrepDrawXY *)


(*
 * INITIALIZE
 * Initializes globals and sets up screen and
 *)
PROCEDURE Initialize;
BEGIN
  Answer := 'Y';
  With Logo Do
  Begin
    (* Four concentric circles, going from innermost to outermost *)
    Radii[1] := RADIUS1;
    Radii[2] := Radii[1] + DELTAR;
    Radii[3] := Radii[2] + DELTAR;
    Radii[4] := Radii[3] + DELTAR;
  End;

  Randomize;
  InitTurtle
END; (* Initialize *)


(*
 * WriteXY:
 * Outputs a string in graphics mode
 *)
PROCEDURE WriteXY(X, Y : Integer; TxtMsg : String);
BEGIN
  PrepDrawXY(X, Y);
  WString(TxtMsg)
END; (* WriteXY *)


(*
 * Status:
 * Outputs a string in the status area (top of screen)
 *)
PROCEDURE Status(LineNum : StatusLine; TxtMsg : String);
VAR
  Y : Integer;

BEGIN
  Y := YMAX - (LineNum * TEXTLINE);
  WriteXY(0, Y, '                                        ');
  WriteXY(0, Y, TxtMsg)
END; (* Status *)


(*
 * MakeCircle:
 * Calculates the points needed for a circle, draws it, and saves the points
 *)
PROCEDURE MakeCircle(XCentre, YCentre, Radius : Integer; VAR ArcY0, ArcY1 : SectorArc);
VAR
  X, Y, X00, X0, X1, Y0, Y1, RR, Delta : Integer;

BEGIN
  Y1 := 0;                              (* Need "prev" value for adjustment *)
  RR := Radius * Radius;                (* Calculate once before beginning *)
  For X := 1 To Radius Do
  Begin
    (* NE Quadrant *)
    X0 := XCentre + X;
    X1 := X0 + 1;
    X00 := X0;                          (* We'll need X0 value again for SE *)

    Y := Round(Sqrt(RR - X*X));
    ArcY0[X] := Y;                      (* Save arc for redrawing next time *)
    Y0 := YCentre + Y;

    ArcY1[X] := ArcY0[X] + 1;           (* Default to nudging the ViewPort *)
    Y1 := Y0 + 1;

    (* Later points adjust based on the last point *)
    If X > 1 Then
    Begin
      Delta := ArcY1[X-1] - Y;
      If Delta > 2 Then
      Begin
        ArcY1[X] := ArcY0[X] + Delta - 1;
        Y1 := YCentre + ArcY1[X]
      End
    End;
    ViewPort(X0, X1, Y0, Y1);
    FillScreen(WHITE);

    (* NW Quadrant *)
    X0 := XCentre - X;
    X1 := X0 + 1;
    ViewPort(X0, X1, Y0, Y1);
    FillScreen(WHITE);

    (* SW Quadrant *)
    Y0 := YCentre - ArcY0[X];
    Y1 := YCentre - ArcY1[X];
    ViewPort(X0, X1, Y1, Y0);           (* Switching bottom and top *)
    FillScreen(WHITE);

    (* SE Quadrant *)
    ViewPort(X00, X00+1, Y1, Y0);       (* Bottom/top switch again *)
    FillScreen(WHITE)
  End
END; (* MakeCircle *)


(*
 * MakeLogo:
 * Draws the Onyx Logo starting at the specified (X,Y) position
 *)
PROCEDURE MakeLogo(X, Y : Integer);
CONST
  HEIGHT = 20;
  TRACKING = 16;

VAR
  S, Section, Theta : Integer;          (* For the O [circle] *)
  Diagonal          : Integer;          (* For the N & X *)
  Xc, Yc, HalfHeight: Integer;          (* For the Y: (Xc,Yc) is the centre *)

BEGIN
  Section := 6;
  Theta := 360 DIV CIRCSECTIONS;
  Diagonal :=  Trunc(Sqrt(TRACKING*TRACKING + HEIGHT*HEIGHT)) + 2;  (* Two? *)
  HalfHeight := HEIGHT DIV 2;

  (* Give me an O *)
  PrepDrawXY(X, Y);
  For S := 1 to CIRCSECTIONS Do
  Begin
    Move(Section);
    Turn(Theta)
  End;

  (* Give me an N *)
  X := X + TRACKING + 1;                (* Kern wider because the O is fat *)
  PrepDrawXY(X, Y);
  TurnTo(90);   Move(HEIGHT);
  TurnTo(-45);  Move(Diagonal);

  (* Give me an Y *)
  X := X + TRACKING;
  PrepDrawXY(X + (TRACKING DIV 2), Y);
  TurnTo(90);   Move(HalfHeight);
  Xc := TurtleX;
  Yc := TurtleY;
  Turn(45);     Move(Diagonal DIV 2);
  PrepDrawXY(Xc, Yc);
  TurnTo(45);   Move(Diagonal DIV 4);

  (* Give me an X *)
  X := X + TRACKING - 1;                (* Kern narrower for Y-X harmony *)
  PrepDrawXY(X, Y);
  TurnTo(45);   Move(Diagonal);
  PrepDrawXY(X, Y + HEIGHT);
  TurnTo(-45);  Move(Diagonal)
END; (* MakeLogo *)


(*
 * MAIN: Displays the Onyx logo
 *)
BEGIN
  Initialize;
  While (Answer <> 'N') AND (Answer <>  'n') Do
  Begin
    Status(1, 'Welcome to Onyx!');
    Status(2, 'We''re setting things up...');
    MakeLogo(100, 40);
    For I := 1 TO NUMCIRCLES Do
      With Logo Do
      Begin
        MakeCircle(XCENTRE, YCENTRE, Radii[I], BegArcY[I], EndArcY[I])
      End;
    Read(KEYBOARD, Answer)
  End;

  (* Say goodbye... *)
  TextMode;
  WriteLn;
  WriteLn('Thank you from Onyx Technologies!');
END.
